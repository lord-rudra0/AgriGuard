import Alert from '../models/Alert.js';
import CalendarEvent from '../models/CalendarEvent.js';

const ALERT_DELAY_MINUTES = {
  info: 360,
  warning: 120,
  low: 360,
  medium: 120,
  high: 45,
  critical: 15
};

const FOLLOWUP_OFFSET_MINUTES = {
  info: 180,
  warning: 60,
  low: 180,
  medium: 60,
  high: 30,
  critical: 15
};

const STALE_CLAIM_MS = 10 * 60 * 1000;

const getDelayMinutes = (severity) => ALERT_DELAY_MINUTES[String(severity || 'medium').toLowerCase()] || ALERT_DELAY_MINUTES.medium;
const getOffsetMinutes = (severity) => FOLLOWUP_OFFSET_MINUTES[String(severity || 'medium').toLowerCase()] || FOLLOWUP_OFFSET_MINUTES.medium;

const isDueForFollowup = (alert, now) => {
  const createdAtMs = new Date(alert.createdAt).getTime();
  const ageMs = now.getTime() - createdAtMs;
  return ageMs >= getDelayMinutes(alert.severity) * 60 * 1000;
};

const buildEventPayload = (alert, now) => {
  const startAt = new Date(now.getTime() + getOffsetMinutes(alert.severity) * 60 * 1000);
  return {
    userId: alert.userId,
    title: `Follow up: ${alert.title}`,
    description: `Auto follow-up for unresolved alert\nSeverity: ${alert.severity}\nMessage: ${alert.message || ''}`,
    roomId: alert.deviceId || null,
    startAt,
    reminders: [{ minutesBefore: 15 }],
    sourceType: 'alert_followup',
    sourceAlertId: String(alert._id),
    autoGenerated: true
  };
};

export const runAutoAlertFollowups = async ({ io, limit = 200 } = {}) => {
  const now = new Date();
  const staleCutoff = new Date(now.getTime() - STALE_CLAIM_MS);
  const candidates = await Alert.find({
    isResolved: false,
    $and: [
      { $or: [{ followupEventId: null }, { followupEventId: { $exists: false } }] },
      { $or: [{ followupProcessingAt: null }, { followupProcessingAt: { $exists: false } }, { followupProcessingAt: { $lt: staleCutoff } }] }
    ]
  })
    .sort({ createdAt: 1 })
    .limit(limit)
    .lean();

  let created = 0;
  let skipped = 0;

  for (const alert of candidates) {
    if (!isDueForFollowup(alert, now)) {
      skipped += 1;
      continue;
    }

    const claim = await Alert.findOneAndUpdate(
      {
        _id: alert._id,
        isResolved: false,
        $and: [
          { $or: [{ followupEventId: null }, { followupEventId: { $exists: false } }] },
          { $or: [{ followupProcessingAt: null }, { followupProcessingAt: { $exists: false } }, { followupProcessingAt: { $lt: staleCutoff } }] }
        ]
      },
      { $set: { followupProcessingAt: now } },
      { new: true }
    ).lean();
    if (!claim) {
      skipped += 1;
      continue;
    }

    try {
      const existingEvent = await CalendarEvent.findOne({
        userId: claim.userId,
        sourceType: 'alert_followup',
        sourceAlertId: String(claim._id)
      }).lean();

      let eventId;
      let scheduledAt;
      if (existingEvent) {
        eventId = String(existingEvent._id);
        scheduledAt = existingEvent.startAt;
      } else {
        const event = await CalendarEvent.create(buildEventPayload(claim, now));
        eventId = String(event._id);
        scheduledAt = event.startAt;
      }

      await Alert.updateOne(
        { _id: claim._id },
        {
          $set: {
            followupEventId: eventId,
            followupScheduledAt: scheduledAt,
            followupSource: 'auto'
          },
          $unset: { followupProcessingAt: 1 }
        }
      );

      io?.to(`user_${String(claim.userId)}`).emit('newAlert', {
        type: 'system',
        severity: 'medium',
        title: 'Auto Follow-up Scheduled',
        message: `A follow-up calendar event was scheduled for unresolved alert: ${claim.title}`,
        timestamp: new Date()
      });

      created += 1;
    } catch (error) {
      await Alert.updateOne({ _id: claim._id }, { $unset: { followupProcessingAt: 1 } });
      console.error('Auto follow-up job error for alert', claim._id, error?.message || error);
    }
  }

  return { created, skipped, scanned: candidates.length };
};
